

# 类与对象

创建对象有两种路线：

1. 在栈上创建对象
2. 在堆上创建对象

## 在栈上创建对象

这是绝大部分时候的做法，对象的生存周期由编译器自动分配和释放

```c++
#include <iostream>

class Test{
  Test() = defult;  
};

int main(){
    {
        Test a; // 在栈上创建对象
    }
	// 过了生存周期，自动删除对象
}
```

## 在堆上创建对象

一般什么时候在堆上创建对象？

1. 由于栈的空间比较小，所以在需要大量创建对象或者需要创建一个内存开销很大的对象时，会在堆上创建对象
2. 想要自己管理对象的生存周期

### 一、new 关键字

```c++
#include <iostream>

class Test{
	Test() = default;  
};

int main(){
    {
        // 在堆上创建对象。
        // 这里分成两步，先是在堆上开辟一块内存，然后创建一个指针指向该内存
        Test* a1 = new Test(); // 注：这会自动调用默认构造函数
        Test* a2 = (Test*)malloc(sizeof(Test)); // 如果是这样的就不会调用默认的构造函数，调用new通常会调用malloc
		Test* a3 = new Test[50]; // 可以这样在内存中得到连续的50个Test

        
        // 到了下面的 } ，类指针的生存周期就要结束了，但是其内存还没有释放，所以要调用delet来释放内存
        delete a1;
        delete a2;
        delete[] a3; // 用 new[] 就要用 delete[]
    }
    
   
}
```



### 二、智能指针 

智能指针能自动清理分配出来的内存

#### 1. unique_ptr 作用域指针

`unique_ptr`是唯一的，不能被复制。因为你复制一个`unique_ptr`时，那么他们两个会指向同一片内存，如果其中一个指针销毁了，那么就会释放那片空间，导致另一个指针指向了以及被释放的内存

```c++
#include <iostream>
#include <memory>

class Test{
    public:
        int a; 
    	Test(){std::cout << "creat Test" << std::endl;}
    	~Test(){std::cout << "destory Test" << std::endl;}
}；

int main{
    {
    	std::unique_ptr<Test> Testptr = std::make_unique<Test>(); // 使用 make_unique 创建 unique_ptr 智能指针
    	// std::shared_ptr<Test> newTestptr(new Test());  // 不推荐用new，可能产生异常安全问题
    	// std::unique_ptr<Test> newTestptr = Testptr;  // <-不能这样做
    }
    // 当作用域指针 unique_ptr 超过作用域时，自动被销毁
}
```



#### 2. shared_ptr 共享指针

与 `unique_ptr`相比，`shared_ptr`可以被复制，因为其内部采用了一个**引用计数**的方式来实现

> 引用计数：追踪指针目前有多少个引用存活，如果引用存活数为0，则删除

`shared_ptr` 本身是一个栈对象（stack object），但它管理的对象通常是在堆上（heap）创建的，最常见的如`make_shared` 

```c++
#include <iostream>
#include <memory>

class Test{
    public:
        int a; 
    	Test(){std::cout << "creat Test" << std::endl;}
    	~Test(){std::cout << "destory Test" << std::endl;}
}；

int main{
    {
        std::shared_ptr<Test> OneTestptr;  // 引用计数：0（空指针）
        {
            std::shared_ptr<Test> TwoTestptr = std::make_shared<Test>(); // 引用计数：1（新对象创建，TwoTestptr拥有所有权）
            OneTestptr = TwoTestptr;  // 引用计数：2（TwoTestptr赋值给OneTestptr，引用计数增加）
            // shared_ptr不用new的原因：shared_ptr需要自己另外分配一块内存，来存储引用计数（控制块）
        }
         // 引用计数：1（TwoTestptr销毁，引用计数减1，现在只有OneTestptr持有对象）
    }
    // 引用计数：0（OneTestptr销毁，引用计数减1，对象被销毁）
}
```



#### 3. weak_ptr 弱指针

将一个`shared_ptr`赋值给另一个`shared_ptr`，会增加`shared_ptr`的引用计数

将一个`shared_ptr`赋值给`weak_ptr`，不会增加`shared_ptr`的引用计数

> weak_ptr的设计是为了解决shared_ptr的循环引用问题。当两个或多个shared_ptr相互引用时，会形成循环引用，导致引用计数永远不会降到0，从而内存泄漏。weak_ptr不增加引用计数，因此它不会影响对象的生命周期。

可以使用 .`lock()` 方法获取 `shared_ptr`，以此来修改`shared_ptr`指向的对象

```c++
#include <iostream>
#include <memory>

class Test{
    public:
        int a; 
    	Test(){std::cout << "creat Test" << std::endl;}
    	~Test(){std::cout << "destory Test" << std::endl;}
}；

int main{
    {
        std::weak_ptr<Test> OneTestptr;
        {
            std::shared_ptr<Test> TwoTestptr = OneTestptr;// 引用计数1
            OneTestptr = TwoTestptr; 
        }
        // 引用计数0
    }
}
```







