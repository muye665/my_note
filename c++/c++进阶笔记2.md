

# 类与对象

创建对象有两种路线：

1. 在栈上创建对象
2. 在堆上创建对象

## 在栈上创建对象

这是绝大部分时候的做法，对象的生存周期由编译器自动分配和释放

```c++
#include <iostream>

class Test{
  Test() = defult;  
};

int main(){
    {
        Test a; // 在栈上创建对象
    }
	// 过了生存周期，自动删除对象
}
```

## 在堆上创建对象

一般什么时候在堆上创建对象？

1. 由于栈的空间比较小，所以在需要大量创建对象或者需要创建一个内存开销很大的对象时，会在堆上创建对象
2. 想要自己管理对象的生存周期

### 一、new 关键字

```c++
#include <iostream>

class Test{
	Test() = default;  
};

int main(){
    {
        // 在堆上创建对象。
        // 这里分成两步，先是在堆上开辟一块内存，然后创建一个指针指向该内存
        Test* a1 = new Test(); // 注：这会自动调用默认构造函数
        Test* a2 = (Test*)malloc(sizeof(Test)); // 如果是这样的就不会调用默认的构造函数，调用new通常会调用malloc
		Test* a3 = new Test[50]; // 可以这样在内存中得到连续的50个Test

        
        // 到了下面的 } ，类指针的生存周期就要结束了，但是其内存还没有释放，所以要调用delet来释放内存
        delete a1;
        delete a2;
        delete[] a3; // 用 new[] 就要用 delete[]
    }
    
   
}
```



### 二、智能指针 

智能指针能自动清理分配出来的内存

#### 1. unique_ptr 作用域指针

`unique_ptr`是唯一的，不能被复制。因为你复制一个`unique_ptr`时，那么他们两个会指向同一片内存，如果其中一个指针销毁了，那么就会释放那片空间，导致另一个指针指向了以及被释放的内存

```c++
#include <iostream>
#include <memory>

class Test{
    public:
        int a; 
    	Test(){std::cout << "creat Test" << std::endl;}
    	~Test(){std::cout << "destory Test" << std::endl;}
}；

int main{
    {
    	std::unique_ptr<Test> Testptr = std::make_unique<Test>(); // 使用 make_unique 创建 unique_ptr 智能指针
    	// std::shared_ptr<Test> newTestptr(new Test());  // 不推荐用new，可能产生异常安全问题
    	// std::unique_ptr<Test> newTestptr = Testptr;  // <-不能这样做
    }
    // 当作用域指针 unique_ptr 超过作用域时，自动被销毁
}
```



#### 2. shared_ptr 共享指针

与 `unique_ptr`相比，`shared_ptr`可以被复制，因为其内部采用了一个**引用计数**的方式来实现

> 引用计数：追踪指针目前有多少个引用存活，如果引用存活数为0，则删除

`shared_ptr` 本身是一个栈对象（stack object），但它管理的对象通常是在堆上（heap）创建的，最常见的如`make_shared` 

```c++
#include <iostream>
#include <memory>

class Test{
    public:
        int a; 
    	Test(){std::cout << "creat Test" << std::endl;}
    	~Test(){std::cout << "destory Test" << std::endl;}
}；

int main{
    {
        std::shared_ptr<Test> OneTestptr;  // 引用计数：0（空指针）
        {
            std::shared_ptr<Test> TwoTestptr = std::make_shared<Test>(); // 引用计数：1（新对象创建，TwoTestptr拥有所有权）
            OneTestptr = TwoTestptr;  // 引用计数：2（TwoTestptr赋值给OneTestptr，引用计数增加）
            // shared_ptr不用new的原因：shared_ptr需要自己另外分配一块内存，来存储引用计数（控制块）
        }
         // 引用计数：1（TwoTestptr销毁，引用计数减1，现在只有OneTestptr持有对象）
    }
    // 引用计数：0（OneTestptr销毁，引用计数减1，对象被销毁）
}
```



#### 3. weak_ptr 弱指针

将一个`shared_ptr`赋值给另一个`shared_ptr`，会增加`shared_ptr`的引用计数

将一个`shared_ptr`赋值给`weak_ptr`，不会增加`shared_ptr`的引用计数

> weak_ptr的设计是为了解决shared_ptr的循环引用问题。当两个或多个shared_ptr相互引用时，会形成循环引用，导致引用计数永远不会降到0，从而内存泄漏。weak_ptr不增加引用计数，因此它不会影响对象的生命周期。

可以使用 .`lock()` 方法获取 `shared_ptr`，以此来修改`shared_ptr`指向的对象

```c++
#include <iostream>
#include <memory>

class Test{
    public:
        int a; 
    	Test(){std::cout << "creat Test" << std::endl;}
    	~Test(){std::cout << "destory Test" << std::endl;}
}；

int main{
    {
        std::weak_ptr<Test> OneTestptr;
        {
            std::shared_ptr<Test> TwoTestptr = OneTestptr;// 引用计数1
            OneTestptr = TwoTestptr; 
        }
        // 引用计数0
    }
}
```



# 杂谈

## cpp从文件到可执行程序的流程

```text
源码(.cpp)
  ↓ 预处理（宏展开）
  ↓ 编译（词法 / 语法 / 语义分析 + 生成 IR / 汇编） gcc
  ↓ 汇编（.s → .o） as
  ↓ 链接（.o → .so / 可执行文件） ld
```

---

## GCC, cpp, g++ 有什么区别？

### 1. cpp 

是由国际标准化组织（ISO）发布的文档，规定了合法的c++语言，是一种纯理论的规则。

### 2. GCC

**是一个工具集合，包含了预处理器、编译器，而且会自己调用汇编器、连接器或加载器等多种工具，而不是单单的一个编译器**。根据cpp的规则来编译你的代码，是真正的把代码转换为机器码的步骤。

### 3. g++

是 GCC 家族中专门用来编译 C++ 的程序。

### 4. 编译器

gcc 只是编译器的一种，常用的编译器还有clang

### 5. 关于GCC, cpp, g++的高质量文章

[clang到底是什么？gcc和clang到底有什么区别？](https://blog.csdn.net/qq_33919450/article/details/130911617)

### 6. 例子

在 ros2 的 rclcpp 中，有这样一个宏

```cpp
#define RCLCPP_EXPORT __attribute__ ((visibility("default")))
```

`__attribute__ `关键字就是是 **编译器（GCC）识别的特殊语法**，用于在定义共享库时，控制对外 API

还可以在运行时查符号，比如在使用 `ros-control `中，少一个 `EXPORT`，`pluginlib` 直接报错

如

```c++
#define RCLCPP_EXPORT __attribute__ ((visibility("default")))

RCLCPP_PUBLIC void spin_some(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr);
```

---

### 关于namespace、using 和 using namespace 

#### 1. `using `和 `using namespace` 的区别

```c++
using std::cout;
cout << "ok" ;  // true
string a;  // flase
    
```

```c++
using namespace std;
cout << "ok" ;  // true
string a;  // true
```

`using` 比 `using namespace` 更加精细一些

#### 2. `namespace` 的作用域

如果是在 {} 内声明，作用范围会被严格限制在该 `namespace` 的内部。

```c++
{
	using namespace std;
	cout << "ok";  // true
}
cout << "ok";  // flase
```

可以用来实现命名空间的组合和别名转发

```c++
namespace printsp
{
	using namespace std;
};
int main(){
    printsp::cout << "ok"; // true
}
```

还有一种别名转发

```cpp
using MyInt = int;
MyInt age = 10; // true

```









